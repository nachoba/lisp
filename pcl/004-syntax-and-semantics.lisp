#|

    FILENAME:            004-syntax-and-semantics.lisp
    AUTOR:               Ignacio Sniechowski
    DATE:                14/10/2017
    REVISION:            16/10/2017
    DESCRIPTION:         From Chapter 4 "Practical Common Lisp"
    SUMMARY:             [01] Introduction
                         [02] Breaking Open the Black Box
                         [03] S-expressions
                         [04] S-expressions as Lisp Forms
                         [05] Function Calls
                         [06] Special Operators
                         [07] Macros
                         [08] Truth, Falsehood, and Equality
                         [09] Formatting Lisp Code   


    CHAPTER 4 - SYNTAX AND SEMANTICS
    --------------------------------

    [01] INTRODUCTION
    -----------------
    In this chapter we will start with an overview of the basic elements of
    Lisp's syntax and semantics.
    Lisp's syntax is different from the syntax of languages descended from Algol.
    The two most important differences are extensive use of parentheses and prefix
    notation.

    [02] BREAKING OPEN THE BLACK BOX
    --------------------------------
    Common Lisp defines two "black boxes"; one that translates text into Lisp
    objects and another that implements the semantics of the language in terms
    of those objects.
    The first box is called the "reader", and the second is called the "evaluator".
    Each black box defines one level of syntax: 

    * The "reader" defines how strings of characters can be translated into Lisp
    objects called "s-expressions". Since the s-expression syntax includes syntax
    for lists of arbitrary objects, including other lists, s-expressions can
    represent arbitrary tree expressions, much like the abstract syntax tree
    generated by the parsers for non-Lisp languages.

    * The "evaluator" then defines a syntax of Lisp "forms" that can be built out
    of s-expressions. Not all s-expressions are legal Lisp forms; for instance,
    (foo 1 2) and ("foo" 1 2) are both s-expressions, but only the former can
    be a Lisp form since a list that startx with a string has no meaning as a
    Lisp form.

    [03] S-EXPRESSIONS
    ------------------
    The basic elements of s-expressions are "lists" and "atoms".
    Lists are delimited by parentheses and can contain any number of whitespace
    separated elemens. Atoms are everything else.
    The elements of lists are themselves s-expressions (in other words, atoms
    or nested lists). Comments are treated as whitespace.
    Since lists are syntactically so trivial, the only remaining syntactic rules
    you need to know are those governing the form of different kinds of atoms.
    Now we will see the most commonly used kinds of atoms: numbers, strings,
    and names.

    * Numbers are fairly straightforward: any sequence of digits (possibly
    prefaced with a signt + or - ), containing a decimal point (.), or a solidus
    (/), or ending with an exponent marker, is read as a number.
    Common Lisp supports integers, ratios, floating-point numbers and complex
    numbers too.
    You can notate the same number in many different ways, but regardless of
    how you write them, all rationals -integers and ratios- are represented
    internally in simplified form.

    * String literals are enclosed in double quotes. Within a string a backslash
    (\) escapes the next character, causing it to be included in the sring
    regardless of what it is. 
    The only two characters that must be escaped within a string are double quotes
    and the backslash itself.

    * Names used in programs, such as "format" "hello-world", and "*db*" are
    represented by objects called symbols. The reader knows nothing about how
    a given name is going to be used -whether it's the name of a variable, a
    function, or something else. It just reads a sequence of characters and
    builds an object to represent the name. While reading names, the reader
    converts all unescaped characters in a name to their uppercase equivalents.
    
    There are certain conventions used when using names. Names are generally
    hyphenated like "hello-world" or "dump-database-to-disk". Also global
    variables are given names that start and end with and asterisk (*), like
    "*db*". Similarly, constants are given names starting and ending with (+).
    Also, some programmers use (%) or (%%) to denote low-level functions.

    For now the key thing to understand is how you can combine numbers, strings
    and symbols with parentheses-delimited lists to build s-expressions
    representing arbitrary trees of objects. Some simple examples look like this:

    x                    ; the symbol X
    ()                   ; the empty list
    (1 2 3)              ; a list of three numbers
    ("foo" "bar")        ; a list of two strings
    (x y z)              ; a list of three symbols
    (x 1 "foo")          ; a list of a symbol, a numbers and a string
    (+ (* 2 3) 4)        ; a list of a symbol, a list, and a number

    The following is a more complex example of a four-item list that contains
    two symbols, the empty list, and another list, itself containing two symbols
    and a string:

    (defun hello-world ()
      (format t "hello, world"))


    [04] S-EXPRESSIONS AS LISP FORMS
    --------------------------------
    After the reader has translated a bunch of text into s-expressions, the
    s-expressions can then be evaluated as Lisp code. The syntactic rules at this
    level are quite simple: any atom (any nonlist or the empty list) is a legal
    Lisp form as is any list that has a symbol as its first element.
 
    The interesting thing about Lisp forms is not their syntax but how they are
    evaluated. You can think of the evaluator as a function that takes as an
    argument a syntactically well-formed Lisp form and returns a value, which we
    can call the "value" of the form.

    The simplest Lisp forms, atoms, can be divided into two categories: symbols
    and everything else.
    A symbol, evaluated as a form, is considered the name of a variable and
    evaluates to the current value of the variable.
    All other atoms -numbers and strings are the kinds we have seen so far- are
    self evaluating objects. This means means when such an expression is passed
    to the notional evaluation function, it's simply returned.
    It's also possible for symbols to be self-evaluating in the sense that the
    variables they name can be assigned the value of the symbol itself. Two
    important constants that are defined this way are "T" and "NIL", the 
    canonical true and false values.

    Another class of self-evaluating symbols are the keyword symbols -symbols 
    whose names start with ":". When the reader interns such a name, it 
    automatically defines a constant variable with the name and with the 
    symbol as the value.

    Things get more interesting when we consider who lists are evaluated. All
    legal list forms start with a symbol, but three kinds of list forms are
    evaluated in three quite different ways. To determine what kind of form
    a given list is, the evaluator must determine whether the symbols that starts
    this list is the name of a function, a macro, or a special operator.

    If the symbol hasn't been defined yet -as may be the case if you're
    compiling code that contains references to functions that will be defined
    later- it's assumed to be a function name.
    We will refer to the three kinds of forms as: function call forms, macro
    forms, and special forms.

    [05] FUNCTION CALLS
    -------------------
    The evaluation rule for function call forms is simple: evaluate the remaining
    elements of the list as Lisp forms and pass the resulting values to the named
    function. This rule obviously places some additional syntactic constraints
    on a function call form: all the elements of the list after the first must
    themselves be well-formed Lisp forms. In other words, the basic syntax of a
    function call form is as follows, where each of the arguments is itself a 
    Lisp form:

    (function-name argument*)

    Thus, the following expression is evaluated by first evaluating 1, then
    evaluating 2, and then passing the resulting values to the + function, which
    returns 3:

    > (+ 1 2)
    3

    A more complex expression such as the following is evaluated in a similar
    fashion except that evaluating the arguments (+ 1 2) and (- 3 4) entails
    first evaluating their arguments and applying the appropriate functions to
    them:

    > (* (+ 1 2) (- 3 4))
    > (* (3)     (-1))
    > (* 3 -1)
    -3

    Eventually, the values 3 and -1 are passed to the * function, which returns
    -3.

    [06] SPECIAL OPERATORS
    ----------------------
    Not all operations can be defined as functions. Because the arguments to a
    function are evaluated before the function is called, there's no way to
    write a function that behaves like the "if" operator. To see why, consider
    this form:

    > (if x (format t "yes") (format t "no"))

    If "if" were a function, the evaluator would evaluate the argument expressions
    from left to right. The symbol x would be evaluated as a variable yielding
    some value; then (format t "yes") would be evaluated as a function call,
    yielding "NIL" after printing "yes" to standard output.
    Then (format t "no") would be evaluated, printing "no" and also yielding "NIL"
    and printing "no". Only after all three expression were evaluated would the
    resulting values be passed to "if", too late for it to control which of the
    two "format" expressions gets evaluated.

    To solve this problem, CL defines a couple dozen so-called special operators,
    "if" being one, that do things that functions can't do. There are 25 in all,
    but only a small handful are used in day-to-day programming.

    When the first element of a list is a symbol naming a special operator, the
    rest of the expressions are evaluated according to the rule for that operator.

    * IF: The rule for "if" is pretty easy: evaluate the first expression. If it
    evaluates to non-nil, then evaluate the next expression and return its value.
    Otherwise, return the value of evaluating the third expression or "nil" if
    the third expression is omitted. In other words, the basic form of an "if"
    expression is as follows:

    > (if test-form then-form [ else-form ])

    The test-form will always be evaluated and then one or the other of the 
    then-form or else-form. 

    * QUOTE: An even simpler special operator is "quote", which takes a single
    expression as its "argument" and simply returns it, unevaluated. For instance,
    the following evaluates to the list (+ 1 2), not the value 3:

    > (quote (+ 1 2))
    (+ 1 2)

    There's nothing special about this list; you can manipulate it just like any
    list you could create with the "list" function. 
    The "quote" operator is used commonly enough that a special syntax for it is
    built into the reader. Instead of writing the following:

    > (quote (+ 1 2))

    You can write:

    > '(+ 1 2)

    This syntax is a small extension of the s-expression syntax understood by the
    reader. From the point of view of the evaluator, both those expressions will
    look the same: a list whose first element is the symbol "quote" and whose
    second element is the list (+ 1 2).

    In general, the special operators implement features of the language that
    require some special processing by the evaluator. For instance, several
    special operators manipulate the environment in which other forms will be
    evaluated. 
    One of these, which we'll discuss in detail in a following chapter, is "let",
    which is used to create new variable bindings. 

    The following form evaluates to 10 because the second x is evaluated in an
    environmnet where it's the name of a variable established by the "let" with
    the value 10:

    > (let ((x 10)) x)
    10


    [07] MACROS
    -----------
    While special operators extend the syntax of CL beyond what can be expressed
    with just function calls, the set of special operators is fixed by the 
    language standard.

    Macros, on the other hand, give users of the language a way to extend its
    syntax. A macro is a function that takes s-expressions as arguments and 
    returns a Lisp form that's then evaluated in place of the macro form.

    The evaluation of a macro form proceeds in two phases:
    First, the elements of the macro form are passed, unevaluated, to the macro
    function.
    Second, the form returned by the macro function -called its "expansion"- is
    evaluated according to the normal evaluation rules.

    It's important to keep the two phases of evluating a macro form clear in
    your mind. It's easy to lose track when you're typing expressions at the
    REPL because the two phases happen one after another and the value of the
    second phase is immediately returned.

    But when Lisp code is compiled, the two phases happen at completely different
    times, so it's important to keep clear what's happening when.
    For instance, when you compile a whole file of source code with the function
    "compile-file", all the macro forms in the file are recursively expanded
    until the code consists of nothing but function call forms and special forms.
    This macroless code is then compiled into a FASL file that the "load" function
    know how to load.

    The compiled code, however, isn't executed until the file is loaded. Because
    macros generate their expansion at compile time, they can do relatively large
    amounts of work generating their expansion without having to pay for it when
    the file is loaded or the functions defined in the file are called.

    Since the evaluator doesn't evaluate the elements of the macro form before
    passing them to the macro function, they don't need to be well-formed Lisp
    forms. Each macro assigns a meaning to the s-expressions in the macro form 
    by virtue of how it uses them to generate its expansion. In other words, each
    macro defines its own local syntax.

    The "backwards" macro defined in the previous chapter, defines a syntax in
    which an expression is a legal backwards form if it's a list that's the 
    reverse of a legal Lisp form.

    For now, the important thing to realize is that macros -while syntactically
    similar to function calls- serve quite a different purpose, providing a hook
    into the compiler.


    [08] TRUTH, FALSEHOOD, AND EQUALITY
    -----------------------------------
    The two last bits of basic knowledge you need to know are CL's notion of
    truth and falsehood and what it means for two Lisp objects to be "equal".
    Truth and falsehood are -in this realm- straightforward: the symbol "nil" is
    the only false value, and everything else is true.

    The symbol "t" is the canonical true value and can be used when you need to
    return a non-nil value and don't have anything else handy. The only tricky
    thing about "nil" is that it's the only object that's both an atom and a list:
    in addition to falsehood, it's also used to represent the empty list.
    
    This equivalence between "nil" and the empty list "()" is buit into the
    reader: if the reader sees "()", it reads it as the symbol "nil". They're
    completely interchangeable. And because "nil", as I mentioned previously, is
    the name of a constant variable with the symbol NIL as its value, the 
    expressions "nil" "()" "'nil" "'()" all evaluate to the same thing -the
    unquoted forms evaluated as a reference to the constant variable whose value
    is the symbol NIL, but in the quoted forms the "quote" special operator 
    evaluates to the symbol directly. For the same reason, both "t" and "'t" will
    evaluate to the same thing: the symbol T.

    Using phrases such as "the same thing" of course begs the question of what it
    means for two values to be "the same". Common Lisp provides a number of type
    specific equality predicates:

    =      is used to compare numbers
    char=  is used to compare characters
    ...

    We will discuss the four "generic" equality predicates -functions that can
    be passed any two Lisp objects and will return true if they're equivalent and
    false otherwise.
    They are, in order of discrimination: "eq", "eql", "equal", and "equalp"

    * "eq" Tests for "object identity" -two objects are EQ if they're identical.
    unfortunately, the object identity of numbers and characters depends on how
    those data types are implemented in a particular Lisp. Thus, "eq" may consider
    two numbers or two characters with the same value to be equivalent, or it may
    not.
    Thus, you should never use "eq" to compare values that may be numbers or
    characters. 

    * "eql" Common Lisp defines "eql" to behave like "eq" except that it also
    is guaranteed to consider two object of the same class representing the same
    numeric or character value to be equivalent. Thus (eql 1 1) is guaranteed to
    be true. And (eql 1 1.0) is guaranted to be false since the integer value 1
    and the floating-point value are instances of different classes.

    There are two schools of thought about when to use "eq" and when to use "eql"
    The "use EQ when possible" camp argues you should use "eq" when you know you
    are not going to be comparing numbers or characters because (a) it's a way to
    indicate that you are not going to be comparing numbers or characters and (b)
    it will be marginally more efficient since "eq" doesn't have to check whether
    its arguments are numbers or characters.

    The "always use EQL" camp says you should never use "eq" because (a) the
    potential gain in clarity is lost because every time someone reading your
    code -including you- sees an "eq", they have to stop and check whether it's
    being used correctly (in other words, that it's never going to be called
    upon to compare numbers or characters) and (b) that the efficiency difference
    between "eq" and "eql" is in the noise compared to real performance bottle
    necks.

    The code in this book is written in the "always use EQL" style.


    The other two equality predicates, "equal" and "equalp", are general in the
    sense that they can operate on all types of objects, but they're much less
    fundamental than "eq" or "eql". They each define a slightly less discriminating
    notion of equivalence than "eql", allowing different object to be considered
    equivalent. There's nothing special about the particular notions of equivalence
    these functions implement except that they've been found to be handy by Lisp
    programmers in the past. If these predicates don't suit your needs, you can
    always define your own predicate function that compares different types of
    objects in the way you need.

    "equal" loosens the discrimination of "eql" to consider lists equivalent if
    they have the same structure and contents, recursively, according to "equal".
    "equal" also considers strings equivalent if they contain  the same characters.
    It also defines a looser definition of equivalence than "eql" for bit vectors
    and pathnames, two data types we will discuss in future chapters. For other 
    types, it falls back on "eql".

    * "equalp" is similar to "equal" except it's even less discriminating. It
    considers two strings equivalent if they contain the same characters, ignoring
    differences in case. It also considers two characters equivalent if they
    differ only in case. Numbers are equivalent under "equalp" if they represent
    the same mathematical value.
    Thus, (equalp 1 1.0) is true. Lists with "equalp" elements are "equalp"
    likewise, arrays with "equalp" elements are "equalp".
    As with "equal", there are a few other data types that we haven't covered yet
    for which "equalp" can consider two objects equivalent that neither "eql" nor
    "equal"  will. For all other data types, "equalp" falls back on "eql".

   
    [09] FORMATTING LISP CODE
    -------------------------
    Code formatting is neither a syntactic nor a semantic matter, but proper
    formatting is important to reading and writing code fluently and
    idiomatically. The key to formatting Lisp code is to indent it properly.

    The indentation should reflect the structure of the code so that you don't
    need to count parentheses to see what goes with what.

    In general, each new level of nesting gets indented a bit more, and, if
    line breaks are necessary, items at the same level of nesting are lined up.
    Thus, a function call that needs to be broken up across multiple lines
    might be written like this:

    > (some-function arg-with-a-long-name 
                     another-arg-with-an-even-longer-name)


    Macro and specil forms that implement control sutrctures are typically
    indented a little differently: the "body" elements are indented two spaces
    relative to the opening parenthesis of the form. Thus:

    > (defun print-list (list)
        (dolist (i list)
          (format t "item: ~a~%" i)))


    In Slime, hitting TAB at the beginning of each line will cause it to be
    indented appropriately, or you can re-indent a whole expression by
    positioning the cursor on the opening parenthesis and typing C-M-q
    Or you can re-indent the whole body of a function from anywhere within it
    by typing C-c M-q    


    Finally, comments should be prefaced with one to four semicolons depending
    on the scope of the comment as follows:

    ;;;; Four semicolons are used for a file header comment
 
    ;;; A comment with three semicolons will usually be a paragraph
    ;;; comment that applies to a large section of code that follows.

    (defun foo (x)
      (dotimes (i x)
      ;; Two semicolons indicate this comment applies to the code
      ;; that follows. Note that this comment is indented the same
      ;; as the code that follows.
      (some-function-call)
      (another i)                     ; this comment applies to this line only
      (and-another)                   ; and this is for this line
      (baz)))


#|

Structure and Interpretation of Computer Programs
-------------------------------------------------
This text reflects two major concerns:

A computer language is not just a way of getting a computer to perform operations
but rather is a novel formal medium for expressing ideas about methodology. Thus,
programs must be written for people to  read,  and only incidentally for machines
to execute.

The essential material to be addressed by a subject at this level is not the syn-
tax of particular programming-language constructs, nor clever algorithms for com-
puting particular functions  efficiently,  nor the mathematical analysis of algo-
rithms, but rather the techniques used  to control the intellectual complexity of
large software systems.

Therefore, computer science is not  a science and its significance  has little to
do with  computers.   The computer revolution is a revolution in the way we think 
and in the way we express what we think.     Mathematics provides a framework for
dealing precisely with notions of "what is",  while computation provides a frame-
work for dealing precisely with notions of "how to".

Chapter 1 :: Building Abstraction with Procedures
-------------------------------------------------
We are about to study the idea of a computational process, which are abstract
beings that inhabit computers. As they evolve, processes manipulate other abs-
tract things called data. The evolution of a process is directed by a pattern
of rules called a program. The programs we use are carefully composed from 
symbolic expressions in arcane and esoteric programming languages that prescribe
the tasks we want our processes to perform.
Well-designed computational systems, like well-designed automobiles or nuclear
reactros, are designed in a modular manner, so that the parts can be constructed
replaced, and debugged separately.

We use Scheme, a Lisp dialect because the language possesses unique features that
make it an excellent medium for studying important programming constructs and 
data structures and for relating them to the linguistic features that support
them. The most significant of these features is the fact that Lisp descriptions
of processes, called "procedures", can themselves be represented and manipulated
as Lisp data. There are powerful program-design techniques that rely on the ability
to blur the traditional distinction between "passive" data and "active" processes.

1.1 The Elements of Programming
-------------------------------
A powerful programming language is more than just a means for instructing a computer
to perform tasks; the language also serves as a framework within which we organize
our ideas about processes. Every powerful language has three mechanisms for accom-
plishing this:
    * Primitive Expressions: Which represent the simplest entities the language is
                             concerned with.
    * Means of Combination : By which compound elements are built from simpler ones.
    * Means of Abstraction : By which compound elements can be named and manipula-
                             ted as units.

1.1.1 Expressions
-----------------

(+ 21 35 12 7)        => 75 

The convention of placing the operator to the left of the operands is known as prefix
notation, and it may be somewhat confusing at first because it departs from the cus-
tomary mathematical convention, but prefix notation has several advantages, one of
them is that it can accommodate procedures that may take an arbitrary number of ar-
guments.

Another advantage of prefix notation is that it extends in a straightforward way to
allow combinations to be nested:

(+ (* 3 5) (- 10 6))  => 19


